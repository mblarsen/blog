<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Blog</title>
    <link href="https://blog.cheesefi.com" />
    <link type="application/atom+xml" rel="self" href="https://blog.cheesefi.com/blog/feed.atom" />
    <updated>2020-05-18T14:44:16+00:00</updated>
    <id>https://blog.cheesefi.com/blog/feed.atom</id>
    <author>
        <name>Michael Bøcker-Larsen</name>
    </author>
                <entry>
    <id>https://blog.cheesefi.com/blog/vue-user-permissions-through-directives</id>
    <link type="text/html" rel="alternate" href="https://blog.cheesefi.com/blog/vue-user-permissions-through-directives" />
    <title>Vue user-permissions through directives</title>
    <published>2017-11-03T00:00:00+00:00</published>
    <updated>2017-11-03T00:00:00+00:00</updated>
    <author>
        <name>Michael Bøcker-Larsen</name>
    </author>
    <summary type="html">This guide is a post-mortem on my experiences from writing &lt;a href=&quot;https://github.com/mblarsen/vue-browser-acl&quot;&gt;vue-browser-acl&lt;/a&gt;, a standalone Vue.js component that brings ACL (Access Control Layer) to the browser in the form of an easily comprehensive directive....</summary>
    <content type="html"><![CDATA[
        <p>This guide is a post-mortem on my experiences from writing <a href="https://github.com/mblarsen/vue-browser-acl">vue-browser-acl</a>, a standalone Vue.js component that brings ACL (Access Control Layer) to the browser in the form of an easily comprehensive directive.</p>

<p>At the end of this article, we will end up with Vue directive that looks something like this:</p>

<pre><code class="language-html">&lt;button v-can:delete="post"&gt;Delete&lt;/button&gt;
</code></pre>

<p>We will cover these topics:</p>

<ul>
<li>Directive arguments and modifiers</li>
<li>A directive’s lifecycle</li>
</ul>

<p>This is not an article about ACL best practice, but a guide to how you can make your code more readable and pleasant to work with for others and your future self.</p>

<h3>Motivation</h3>

<p>Vue provides you with <code>v-if</code> and <code>v-show</code> out of the box and I’m sure your templates, like mine, are littered with these two directives.</p>

<p>They are the equivalent of the <em>if-else</em> control structure we know from our code and, not surprisingly, we often end up having long and deep conditions that force you to stop in order to read them to understand.</p>

<pre><code class="language-html">&lt;button v-if="job.users.contains(user) &amp;&amp; user.isManager()"&gt;Delete&lt;/button&gt;
</code></pre>

<p>Often in Vue you would extract these into computed properties or a component method to hide away the complexity:</p>

<pre><code class="language-html">export default { methods: { canDelete(job) { return
this.job.users.contains(this.user) &amp;&amp; this.user.isManager() } } }
</code></pre>

<p>This lets us simplify the button’s condition:</p>

<pre><code class="language-html">&lt;button v-if="canDelete(job)"&gt;Delete&lt;/button&gt;
</code></pre>

<p>However, this doesn’t scale well. You will have to duplicate this or similar code to all of your components whenever you want to check the user’s permissions for a certain action or view.</p>

<p>Mix-ins are a great way to leverage code duplication. You can also extend the vue prototype like we’ve done for years in JavaScript. (I’ll refer to both approaches as mix-ins for simplicity). Mix-ins allow us to consolidate all the access code in one place and make it available from all Vue components. For example, we could add a <code>$can</code> mix-in (in fact, we will do that later) and now transform the button to something like this:</p>

<pre><code class="language-html">&lt;button v-if="$can('delete', job)"&gt;Delete&lt;/button&gt;
</code></pre>

<p>Although mix-ins are vastly better and for most parts get the job done, I believe that we can do better with directives.</p>

<h3>ACL Primer</h3>

<p>First, I’ll briefly cover our requirements. ACL in the browser is mostly there for UX purposes and is no replacement for checking permissions in the backend.</p>

<p>There are many approaches to ACL. There are different granularities and ways of expressing permissions, but it basically boils down to defining how a user, possibly through a role, can perform certain actions (or verbs) on the models in your application. The actions can be anything really: create, view, edit, delete, transfer, send, manage members, etc.</p>

<p>The library we are using is kind of agnostic about users and roles as long as you pass in something your rules can make sense of.</p>

<p>As to the models in your app, there is distinction between classes and instances. When you have an instance of something, say a post, and you want to determine if an edit button should be enabled, you would likely check if the current user is the owner of the post.</p>

<pre><code class="language-html">acl.rule('edit', Post, (user, post) =&gt; user.id === post.userId)
</code></pre>

<p>The point is that for the verb <em>edit</em> we will need an instance of a post to determine the permission.</p>

<p>For a verb like <em>create,</em> on the other hand, we won’t be able to provide an instance since the post doesn’t exist yet. But we will have to pass something for the ACL to be able to determine if the user should be able to create a post:</p>

<pre><code class="language-js">acl.rule("create", Post, (user) =&gt; user.isRegistered())
</code></pre>

<p>So in this case, we can either pass the class of Post or a string ‘Post’ instead of an actual instance.</p>

<p>In the example above, the <em>create</em> action can only be performed in case the user is registered. An important point is that the <code>Post</code> argument is only used to tell that the rule is about posts and it is not used in the code that determines the permission; only the user is.</p>

<p>This is not terribly important, but it will guide us in some of the choices we’ll make when designing the <code>v-can</code> directive going forward.</p>

<h3>Vue.use()</h3>

<p>Directives and mix-ins alike are plugged into Vue by calling <code>use(plugin)</code>. It expects an object with a method called <code>install</code>. Vue calls the method and includes itself as the first argument. And each argument you pass to <code>use</code> after that will be passed to install as well. (see <a href="https://vuejs.org/v2/guide/plugins.html">plugins</a> section)</p>

<pre><code class="language-js">Vue.use({
  install(Vue, options, moreOptions, evenMoreOptions) {
  ...
  }
})
</code></pre>

<h3>Defining rules (options)</h3>

<p>For this particular directive, the plugin user will need to:</p>

<ul>
<li>Provide access to the current user</li>
<li>Define some rules which are the base for the ACL to work</li>
</ul>

<p>There are several ways to provide these.</p>

<p>You can set up all rules and configurations on an object and then pass it ready with rules and all to Vue like so:<code>Vue.use(instance)</code>. This is what <code>vue-router</code> does.</p>

<p>You can also simply pass in the plugin and then do all the configuration in the install function. However, we want to hide away the “mess” of importing and creating an Acl instance, but we still need to expose this instance so that the plugin user can add rules to it.</p>

<p>It could look something like this:</p>

<pre><code class="language-js">import Acl from "vue-browser-acl"

Vue.use(Acl, user, (acl) =&gt; {
  acl.rule("edit", "Post", (user, post) =&gt; user.id === post.userId)
})
</code></pre>

<p>First, we pass our plugin <em>Acl</em> (remember a plugin is just an object with an install function) and secondly, we pass the <em>user</em>. There are no requirements as to what a user is. It can be an email, an object, a role, or even null. We will use this later to pass to the Acl’s <code>can()</code> function.</p>

<p>The third parameter is a callback that provides the <em>acl</em> instance (code we still have to write) as the first and only parameter.</p>

<p>Using a callback is a way to expose what is relevant to configure the plugin, and hide away everything else.</p>

<p>In the above code, we define a single rule — a rule for checking if a user may edit a post or not.</p>

<p>Before starting on the directive, we will add the mix-in or helper function that is still useful for cases where you cannot use the directive. See <a href="https://github.com/mblarsen/vue-browser-acl#helper">a few examples</a> in the the released package.</p>

<p>Let’s look at our plugin and how we can provide the proposed API.</p>

<pre><code class="language-js">import Acl from 'browser-acl'

export default {
  install: function (Vue, user, callback, options) {
    const acl = new Acl(options) callback(acl)
  }
}
</code></pre>

<p>That is really all it takes. Note that I’ve added the option for a third argument in case you want to pass options to the underlying ACL module.</p>

<p><img src="/assets/img/v-can-poi.png" alt="" />
<em>I use <a href="https://poi.js.org">poi</a> to build and bundle the package. Poi lets you use all the features of Webpack without having to configure anything.</em></p>

<h4>Helper Function</h4>

<p>Our ACL is now hooked up but we are still unable to do anything with it. Let’s add the helper function before starting on the directive.</p>

<pre><code class="language-js">import Acl from "browser-acl"

export default {
  install: function(Vue, user, callback, options) {
    const acl = new Acl(options)
    callback(acl)
    Vue.prototype.$can = (...args) =&gt; acl.can(user, ...args)
  },
}
</code></pre>

<p>Adding a helping function is easy. We add a function <code>$can</code> to the <code>Vue.prototype</code> after which all Vue instances can access the helper function. That means we make use of the function already:</p>

<pre><code class="language-html">&lt;button v-if="$can('edit', post)"&gt;Edit&lt;/button&gt;
</code></pre>

<p>It is important to point out that <code>post</code> must exist as data (or computed value) on the component or must reference a variable in a loop (<code>v-for="post in posts"</code>).</p>

<p>Now that the ACL functionality is in place, it is time to create the directive.</p>

<h3>Directives 101</h3>

<p>The <a href="https://vuejs.org/v2/guide/custom-directive.html">documentation for directives</a> is pretty good, so I won’t go into much detail, but I will only cover the the parts that are relative to our can-directive and likely for most directives you’ll ever write yourself.</p>

<p>This was the example we started out with — accompanied with a few other familiar “faces”:</p>

<pre><code class="language-html">&lt;button v-can:delete="post"&gt;Delete&lt;/button&gt;
&lt;input v-on:keyup.enter.prevent="validate" /&gt;
&lt;a class="btn btn-link" @click.prevent="save"&gt;Save&lt;/a&gt;
</code></pre>

<p>To break it down further into detail, the directives above are:</p>

<p><code>v-can</code> with an <strong>argument</strong> <code>delete</code> and an the <strong>value expression</strong> <code>post</code>.</p>

<p><code>v-on</code> with an <strong>argument</strong> <code>keyup</code> and a <strong>modifiers</strong> <code>enter</code> and <code>prevent</code>.</p>

<p><code>@click</code> is syntactic sugar for <code>v-on:click</code> but, as such, acts as a directive with a <strong>modifier</strong> <code>prevent</code>.</p>

<p><strong><em>The name of a directive</em></strong> is the name without the <code>v-</code> and this is how you register them: <code>can</code>, <code>on</code></p>

<p><strong><em>A directive can have a single argument</em></strong> that always comes after the directive name. For <code>v-on</code> the argument is used to specify which event to listen on: <code>keyup</code>, <code>click</code>, to name a few.</p>

<p><strong><em>A directive can have multiple modifiers</em></strong>. Modifiers are like flags, boolean values, that your directive can react upon. For <code>v-on</code>, modifiers like <code>prevent</code> and <code>stop</code> are used to invoke<code>preventDefault</code> and <code>stopProrogation</code> respectively on the event when fired.</p>

<p>Modifiers can also be used as <strong><em>passing additional arguments</em></strong>. Although this is not the intended usage, this is clearly an accepted practice as seen from the above example in the case of <code>enter</code>. Modifiers will be available as an object with the value true like <code>{enter: true, prevent: true}</code>. Since they are converted into an object with the modifier names as keys, there are limits to how you can use modifiers as extra arguments:</p>

<ul>
<li>There is no guarantee of the order</li>
<li>You cannot have repeated values</li>
</ul>

<p>So if, for example, we were making a media query directive and wanted to use modifiers for arguments:</p>

<pre><code class="language-html">&lt;div v-mq.min.764.max.1024&gt;Content only shown for medium devices&lt;/div&gt;
</code></pre>

<p>This would not work since we wouldn’t know if min or max is referring to 764 or 1024. You would have to device some clever logic to make it work at least.</p>

<h3>v-can</h3>

<p>(well can we?)</p>

<p>With that out of the way, let’s define the requirements for our directive. We will need to pass in at least two arguments: the verb and an object to check if the user can perform the action on it.</p>

<p>Often, you don’t want to hide an element like a button but you may just want to disable it. In UX land, this translates to telling the user that an action exists but currently, for some reason, you cannot perform it.</p>

<p>So for the directive, we have to figure out a syntax that covers the following: <strong>verb</strong> , <strong>object</strong> , <strong>hide</strong> option (the default) and an option to <strong>disable</strong>.</p>

<p>We could wrap all this up in an a object and pass it as the value to the directive, but we want to make use of directive arguments and modifiers of course.</p>

<p><em>hide</em> and <em>disable</em> are mutually exclusive so there can only ever be one value which makes a good candidate for the argument: <code>v-can:hide</code> or <code>v-can:disable</code>.</p>

<p>However, recalling <code>v-on:keyup</code>, it seems that the argument is complementing the name of the directive to describe an event “on keyup”. It nicely describes what the directive does: a binding for what happens when the key is released.</p>

<p>Returning to <code>v-can:hide</code> we get “can hide” which is really not what our directive is about. We want it to read what the user can do, or rather what the user must be able to do in order for the element to be shown or enabled.</p>

<p>Verbs, too, for the most part, are singular arguments. For posts, the verbs could be: <em>create</em>, <em>edit</em>, <em>delete</em>, and <em>comment</em>. These verbs would translate into usage like <code>v-can:create</code>, <code>v-can:edit</code>, and so on. This reads really well: “can create” and “can edit”. There is no doubt what the directive is about.</p>

<p>That leaves <em>hide</em> and <em>disable</em> as well as the object (a post). For the object, we don’t have an option really; it has to be the value.</p>

<p>As we’ve already departed from the idea of providing arguments as a value object, that means <em>hide</em> and <em>disable</em> will have to be modifiers. Which isn’t so bad really. “should hide” or “should disable” are boolean values. Perfect.</p>

<p>That leaves us with:</p>

<pre><code class="language-html">&lt;button v-can:edit.disable="post"&gt;Edit&lt;/button&gt;
</code></pre>

<ul>
<li>The verb is the argument</li>
<li>Hide/disable are mutually exclusive modifiers</li>
<li>The object is the value expression</li>
</ul>

<p>Note: The published package supports <a href="https://github.com/mblarsen/vue-browser-acl#flavors">other flavors</a> that in some cases make more sense — e.g. you can write <code>v-can="'create Post'"</code> and there is an option to pass verb, object and additional arguments to the rules using an array notation. In addition, it has modifiers that work on a collection of objects.</p>

<h3>Implementation</h3>

<p>We add directives using <code>Vue.directive()</code>. It takes as the <em>first argument</em> the name of the argument without the <code>v-</code> prefix. So in our case, just <code>can</code>.</p>

<p>The <em>second argument</em> can either be an update function or an object detailing the directive’s lifecycle hooks for greater control. We will implement this using an update function but we will cover the second option in the directive’s lifecycle section below.</p>

<p>The function will be called initially when the containing element is created and will be called subsequently when data changes. It takes three arguments <code>function (el, binding, vnode)</code> of which <code>bindings</code> is the most interesting to us. <code>el</code> is the DOM element and <code>vnode</code> is Vue’s virtual dom node (you can access data properties from there).</p>

<p>The <strong>binding argument</strong> gives you access to the argument, modifiers, the value and so on.</p>

<ul>
<li><code>name</code>: The name without the <code>v-</code> prefix</li>
<li><code>value</code>: The value after evaluating the expression (you can also get the expression itself)</li>
<li><code>arg</code>: The argument</li>
<li><code>modifiers</code>: An object with the modifier name for key and true for value</li>
</ul>

<p>For a complete list of binding properties, <a href="https://vuejs.org/v2/guide/custom-directive.html#Directive-Hook-Arguments">see the docs</a>.</p>

<pre><code class="language-js">...
Vue.directive('can', function (el, bindings, vnode) {
  const behaviour = binding.modifiers.disable ? 'disable' : 'hide'
  const ok = acl.can(user, binding.arg, binding.value)

  if (!ok) {
    if (behaviour === 'hide') {
      commentNode(el, vnode)
    } else if (behaviour === 'disable') {
      el.disabled = true
    }
  }
})
...
</code></pre>

<p>Default to hide: First, we check to see if the <code>disable</code> modifier is there. If not, then default to hide, in the same way<code>v-if</code> works.</p>

<p>Next, check if we have permission to perform the action. The <code>acl</code> is in scope since we are still inside the install function of our plugin.</p>

<p>In the event the user is not authorized, e.g. to edit a post, then we deal with the element accordingly. In the event the user is authorized, we do nothing.</p>

<p>The easy case is <em>disable.</em> We turn on the <code>disabled</code> property of the element. That is the equivalent of:</p>

<pre><code class="language-html">&lt;button disabled&gt;Edit&lt;/button&gt;
</code></pre>

<p>For <em>hide</em> it is a bit more complicated. The basic idea is that you replace the content with an empty comment <code>&lt;!-- —-&gt;</code>. You can <a href="https://github.com/mblarsen/vue-browser-acl/blob/4e3bb90d2ba4fcc3edd30b27737f4531dc464329/index.js#L136-L163">see the code here</a>.</p>

<p><strong>That’s it. This is the implementation of the directive.</strong></p>

<p>We have completed our directive which lets us write more succinct templates using <code>v-can</code>. There are many ways to improve on the implementation, but this is the gist of it.</p>

<p><img src="/assets/img/v-can-example.png" alt="" />
<em>An example of the v-can directive in production (“can assign&nbsp;job”).</em></p>

<h3>Directive Lifecycle</h3>

<p>I left this bit for the last, in order to add a few more words on what happens when we provide the update function.</p>

<p>Just like a Vue component has lifecycle hooks (<em>created</em>, <em>mounted</em>, <em>before&#42;</em>, etc.) so do directives. However, for most directives, you’ll only ever use two of them: <em>bind</em> and <em>update</em>. Think of them as analogous to <em>mounted</em> and <em>beforeUpdate</em> for components respectively.</p>

<blockquote>
  <p>In many cases, you may want the same behavior on <code>bind</code> and <code>update</code>, but don’t care about the other hooks.</p>
</blockquote>

<p>For that reason, Vue provides a <a href="https://vuejs.org/v2/guide/custom-directive.html#Function-Shorthand">function shorthand</a> which is what we used in our implementation. This assigns the update function to both hooks.</p>

<pre><code class="language-js">Vue.directive("can", canImplementation)
</code></pre>

<p>is equivalent to:</p>

<pre><code class="language-js">Vue.directive("can", { bind: ourImplementation, update: ourImplementation })
</code></pre>

<p><strong>Bind</strong> happens once when the directive has been associated with an element (el) after which, it is never called again.</p>

<p><strong>Update</strong> happens as data changes through the reactiveness of Vue — from user input or some side-effect. For the <code>v-can</code>, the object of our ACL is what can change. So say the post bound to the component changes to a different post, then the ACL re-evaluates the user’s permissions.</p>

<p>Note: The update hook takes a fourth argument <em>oldVnode</em> and the bindings object also includes <em>bindings.oldValue</em>. This lets you compare the old and new values to avoid doing unnecessary computations.</p>

<p>The other hooks are: <em>componentUpdated</em>, <em>insert</em> and <em>unbind</em>.</p>

<p><strong>Unbind</strong> is similar to <em>beforeUnmount</em> and <em>beforeDestroy</em>. It lets you properly tear down whatever objects you have created. Say for instance you are making a directive that will play a sound on hover. Before the component (and thus the directive as well) is disposed off, you would need to stop the audio from playing. Otherwise, it would keep living in the browser, taking up a hardware audio channel.</p>

<p>See the Vue documentation for <em>insert</em> and <em>componentUpdated</em>.</p>

<h3>What’s next?</h3>

<p>As an exercise for you, try to see if you can implement the string flavor so that you can write: <code>v-can="'edit post'"</code> or <code>v-can="'create Post'"</code> for instances and classes respectively.</p>

<p>Hint: you might need <code>vnode.context</code></p>

<p>This was an exercise for me in sharing my experiences developing this Vue directive. Questions and feedback are most welcome.</p>

<p>If you got this far, thank you for your attention :)</p>

<p>P.S. Do check out <code>poi</code> and <code>poi-preset-karma</code> which let you develop and unit test Vue components with zero config.</p>
    ]]></content>
</entry>
            <entry>
    <id>https://blog.cheesefi.com/blog/wordpress-style-shortcodes-using-vue</id>
    <link type="text/html" rel="alternate" href="https://blog.cheesefi.com/blog/wordpress-style-shortcodes-using-vue" />
    <title>WordPress-style shortcodes using Vue</title>
    <published>2017-03-15T00:00:00+00:00</published>
    <updated>2017-03-15T00:00:00+00:00</updated>
    <author>
        <name>Michael Bøcker-Larsen</name>
    </author>
    <summary type="html">If you have worked with WordPress as a blogger or developer before, you will undoubtedly know that most sites are built by extensive plugins that spit out shortcodes. To me, WordPress has always seemed a bit like a hack. Everything is squeezed into the......</summary>
    <content type="html"><![CDATA[
        <p>If you have worked with WordPress as a blogger or developer before, you will undoubtedly know that most sites are built by extensive plugins that spit out <strong>shortcodes</strong>. To me, WordPress has always seemed a bit like a hack. Everything is squeezed into the <code>Post</code> model, whose main body contains more content types and ad hoc data types, depending what content-plugins you've installed. Yikes!</p>

<p>However, this is how it works and the wast number of themes, plugins, and users must be a testament to its success.</p>

<blockquote>
  <p><code>[gallery id="123" size="medium"]</code></p>
</blockquote>

<p>That is a shortcode from the documentation of <a href="https://codex.wordpress.org/Shortcode_API">Wordpress' Shortcode API</a>. Shortcodes are easy to read and understand. Although most of them are generated by a UI tool, anyone could author them by hand. Even as a blogger, you’d most likely have to every now and then.</p>

<p>The idea of shortcodes is that they provide a super simple content and layout language. When I was asked to help build a project that utilizes shortcodes in a themeable Vue.js application, I was quite excited to see how you could map these shortcodes onto Vue.js components and layout. This concept could provide a tool for site owners to customize the site beyond what was achievable with CSS.</p>

<p>The app we are building has a number of pages. Each of the pages has a few areas that can be customized; some have more customizable areas than others. For example, a checkout page in a web shop would normally have less customization options than the shop’s front page, where almost all content and layout could be changed in various ways. We call these areas <strong>slots</strong>.</p>

<p>The general idea is to come up with a number of basic components that a theme-developer can style and provide a basic layout for. The application structure remains the same in terms of pages, but the layout and content in each of the slots can vary.</p>

<h2>Goal: Turn shortcodes into Vue components</h2>

<p>Our goal in the building of this app is to be able to add both layout and content components to our shortcode Vue.js integration. For example:</p>

<pre><code class="language-html">&lt;h2&gt;Products&lt;/h2&gt;
[row] [col class="s6"] [product-list name="featured" use="product-card" num=3/]
[/col] [col class="s6"] [product-list name="bestsellers" use="product-card"
num=3/] [/col] [/row]
</code></pre>

<p>In the above example, the row and col(umn) tags represent layout components whereas product-list and product-card will be turned into content components.</p>

<p>Since Vue is all about creating new components and extending the HTML vocabulary, we thought we’d use our Vue components directly. However, the app we are building excessively targets users in the WordPress community. Therefore, we wanted to try this approach.</p>

<p>Basically these are the steps we need to go through:</p>

<ol>
<li>Convert the string we get from the backend into some other data structure so we can alter the layout and content.</li>
<li>Figure out how we can map the codes to our components, like the ProductList or a ProductCard.</li>
<li>Figure out how to use Vue.js to construct a new component that can instantiate our components.</li>
</ol>

<p>.. and then finally: Demo Time!</p>

<h3>Step 1: Abstract Syntax Tree</h3>

<blockquote>
  <p>Convert the string we get from the backend into some other data structure so we can reason about layout and content.</p>
</blockquote>

<p>This first step is not so interesting. I have built a small library, <a href="https://github.com/mblarsen/shortcode-tokenizer">shortcode-tokenizer</a>, for lexing the sample block above and spitting out an Abstract Syntax Tree (AST).</p>

<p>From the example above, we get an array of nested objects similar to this:</p>

<pre><code class="language-js">[
    {
        type: 'TEXT',
        body: "&lt;h1&gt;Products&lt;/h1&gt;"
        pos: 0
    },
    {
        type: 'OPEN',
        name: 'row',
        pos: 18,
        body: '[row]',
        isClosed: true,
        params: {},
        children: [
            ... a whitespace TEXT token ...,
            {
                type: 'OPEN',
                name: 'col',
                pos: 26,
                body: '[col class="s6"]',
                isClosed: true,
                params: {
                    class: 's6'
                },
                children: [ ... and so on ... ]
             }
        ]
    }
]
</code></pre>

<p>It provides us with a nested object structure that has all parameters prepared and all the elements labeled as text, self-closing, or regular shotcode.</p>

<p>We will use this data structure as the source of what to build in Vue.</p>

<h3>Step 2: Mapping codes to components</h3>

<blockquote>
  <p>Figure out how we map the codes to our components like the <code>ProductList</code> or a <code>ProductCard</code>.</p>
</blockquote>

<p>Vue components are typically named according to the import of the parent component, but Vue is quite flexible and you can reference your components in a number of ways: <code>TitleCase</code>, <code>lowerTitleCase</code>, and <code>kebab-case</code>. The latter is the same syntax we would use for our shortcodes, so this shouldn't be too hard. In most cases, we can just use the same name to refer to the Vue components:</p>

<pre><code class="language-js">export default {
  components: {
    ProductList,
  },
}
</code></pre>

<p><code>ProductList</code> can now, as you know, be referenced as <code>&lt;product-list&gt;</code> in the component template, thanks to a little vue-magic. Vue exposes its name tranformation functions through <code>Vue.util</code>. We will make use of them later.</p>

<p>An argument for making an explicit map: the code name and component name may differ because they follow different guidelines. For example, we have used <code>[col]</code> for a column above, which is a shorthand for a component name. I prefer full words as it reads more easily, but in shortcode land, it's okay to go with the short form — it mirrors the <code>[row]</code> code well (things that look alike...).</p>

<p>So although we don’t actually need to map the code names, this would still be a good idea because it wouldn’t mess with the way we like to work with Vue.</p>

<p>Another benefit is that we can refer to this map during the parsing. Additionally, in case we come across an unknown code (by absence in the map), we can treat it as an error in the same place as syntax errors—rather than having to let the errors occur in the Vue runtime when trying to instantiate components that do not exist.</p>

<p>So let us create a map:</p>

<pre><code class="language-js">const codeMap = {
  col: "column",
  row: "row",
  "product-list": "product-list",
}
</code></pre>

<p>The <strong>key</strong> is the shortcode and the <strong>value</strong> is the kebab-cased name of our Vue components.</p>

<h3>Step 3: Wrapping up (or getting started)</h3>

<blockquote>
  <p>Figure out how to use Vue to construct a new component that can instantiate our components.</p>
</blockquote>

<p>Now that we have an AST, we need to parse or render into templates and components using the map we defined in the previous step.</p>

<p>Vue provides a few built-in components that can make your pages more dynamic in the sense that you don’t have to specify what components are rendered or how they are rendered beforehand. These are <code>&lt;component&gt;</code> and <code>&lt;slot&gt;</code> respectively.</p>

<p>The <code>&lt;component&gt;</code> component’s functionality is close to what we want. However, we have to include all our components on every page and in every parent component where we want to use or shortcode slot, since the slot, in theory, could contain references to all of our components.</p>

<pre><code class="language-vue">&lt;template&gt;
  &lt;component :is="chosenComponent"&gt;&lt;/component&gt;
&lt;/template&gt;
&lt;script&gt;
import Row from "components/Row"
import Column from "components/Column"
import ProductList from "components/ProductList"
import ProductCard from "components/ProductCard"
// ... and so on ...

export default {
  components: {
    Row,
    Column,
    ProductList,
    ProductCard,
    // ... and so on  ...
  },
  data() {
    return { chosenComponent: "product-list" }
  },
}
&lt;/script&gt;
</code></pre>

<p>This a bit cumbersome to say the least. We don’t want to repeat this for each parent component. This chore needs to be encapsulated as well.</p>

<h3>Requirements</h3>

<p>So let's wrap this up. We will make a new component that is similar to <code>&lt;component&gt;</code>, but one that has knowledge of all the components that we want to expose to the shortcode slot. We will call this <code>&lt;code-slot&gt;</code>.</p>

<p>But first, recall our template is a mixture of text (HTML) and shortcodes. Basically, we can have text all around and between each of the open and close codes. We need to add this to the template as well.</p>

<p>When you have highly dynamic content, <code>&lt;component&gt;</code> and <code>&lt;slot&gt;</code> might not be enough. In that case, you can write your own render function.</p>

<p>(Internally, all your templates are turned into render functions.)</p>

<p>Our component acts as a controller in terms of what gets rendered but doesn’t add any value content or functionality besides the content of the slot. For these kinds of scenarios, you would go for a <a href="https://vuejs.org/v2/guide/render-function.html#Functional-Components">functional component</a>, because it has less overhead as it does not maintain state. You would simply pass on control to another component. However, since we also have to render the text, we don’t have a single component that can handle all our needs. For this reason, we will use a regular component.</p>

<p>(If anyone knows if and how the following can be made as a functional component, I would love to learn how!)</p>

<p>Here goes. We will need Vue and the tokenizer:</p>

<pre><code class="language-vue">// components/CodeSlot.vue import { default as Tokenizer } from
'shortcode-tokenizer' import Vue from 'vue'
</code></pre>

<p>We also want to import all the components we want to include as shortcodes:</p>

<pre><code class="language-js">import Row from "components/Row"
import Column from "components/Column"
import ProductList from "components/ProductList"
import ProductCard from "components/ProductCard"
</code></pre>

<p>Then we add our map, but with a little twist. We need the map in two cases.</p>

<ol>
<li>to get the kebab-cased name for building the template</li>
<li>to pass into the <code>components:</code> property of our component, so instead of mapping from code to component name, we will map directly to the imported component:</li>
</ol>

<pre><code class="language-js">const codeMap = {
  row: Row,
  column: Column,
  col: Column,
  "product-list": ProductList,
  "product-card": ProductCard,
}

const allComponents = Object.values(codeMap).reduce((all, c) =&gt; {
  all[Vue.util.hyphenate(c.name)] = c
  return all
}, {})
</code></pre>

<p>Note that we have both <code>col</code> and <code>column</code> in <code>codeMap</code> — this means that both can be used as shortcodes. However, Vue will complain if you try to use <code>col</code> because this is already an HTML tag. Instead of using the code map directly, we'll map it to a new object where the key is based on a hyphenated (kebab) version of the component’s name.</p>

<p>(Note: if you are using Webpack or something similar, you’ll need to add a <code>name:</code> property to your components. Otherwise, the name will be an odd internal Webpack value.)</p>

<h3>The Component</h3>

<p>So let's start to flesh out the actual component:</p>

<pre><code class="language-js">export default {
    props: {
        content: {
            type: String,
            required: true
        },
        strict: {
            type: Boolean,
            default: true
        }
    },
    methods: {
        renderContent() {
            // Turn AST into template and handle syntax error
        }
    },
    created: {
        this.tokenizer = new Tokenizer()
    },
    render(h) {
        return h(Vue.component('code-wrapper', {
            template: this.renderContent(),
            components: allComponents
        }))
    }
}
</code></pre>

<p>The idea behind this approach is to programmatically create yet another component — <code>&lt;code-wrapper&gt;</code> — as a child of our <code>&lt;code-slot&gt;</code> component. In our template code of a parent component, we include the code slot:</p>

<pre><code class="language-html">&lt;aside&gt;
  &lt;code-slot :content="sidebarContent"&gt;&lt;/code-slot&gt;
&lt;/aside&gt;
</code></pre>

<p>So say that we put a product list in the sidebar slot:</p>

<pre><code class="language-html">&lt;h3&gt;Featured&lt;/h3&gt;
[product-list name="featured" num=3 use="product-card"/]
</code></pre>

<p>Then our Vue hierarchy will end up looking like this:</p>

<p><img src="/assets/img/vue-wordpress-inspector.png" alt="Vue hierarchy from the Chrome developer tool" />
(CodeSlot is our controlling component that creates CodeWrapper which is a template that contains both HTML and our custom component ProductList)</p>

<h3>Rendering</h3>

<p>I will not cover the entire rendering process but you can look into it more in <a href="https://gist.github.com/mblarsen/f628fc3c196b5f58d326242061922446">this gist</a> which includes the component in its entirety.</p>

<p>The body of this function can be kept pretty simply. An important part is how we handle syntax errors to prevent our Vue application from running astray.</p>

<pre><code class="language-js">export default {
    ...
    methods: {
      renderContent() {
        try {
          let ast = this.tokenizer
            .input(this.content)
            .ast()
          let content = ast
            .map(renderToken)
            .join('')
          return ensureOneRoot(ast, content)
        } catch (err) {
          console.error(err)
          return `&lt;div class="error"&gt;${err.message}&lt;/div&gt;`
        }
      }
    }
    ...
}
</code></pre>

<p>Our content prop value (from our parent) is passed into the tokenizer, which returns an AST, an array of root tokens. We pass each token into render function (not shown here), which returns a part of our final template that we then join with all the other parts. Lastly, before returning, we ensure that the generated template only has one root — a requirement of Vue components.</p>

<p>In the rendering process, I’m simply passing the tokens through a series of transformer functions recursively. As an example, this is the render function for codes that has an open and a close part:</p>

<pre><code class="language-js">function renderOpen(token) {
  if (token.type === Tokenizer.OPEN) {
    let name = getComponentName(token)
    let params = renderParams(token)
    let children = token.children.map(renderToken).join("")
    token.output = `&lt;${name}${params}&gt;${children}&lt;/${name}&gt;`
  }
  return token
}
</code></pre>

<p>You don’t have to mirror AST exactly. You can skip nodes, add new ones, or as in this example, the <code>keep-alive</code> parameter is converted into a wrapper of the component:</p>

<pre><code class="language-js">// example input: [product-list keep-alive/]
function wrapKeepAlive(token) {
  if (typeof token.params["keep-alive"] !== "undefined") {
    token.output = `&lt;keep-alive&gt;${token.output}&lt;/keep-alive&gt;`
  }
  return token
}
</code></pre>

<h3>Error Handling</h3>

<p>You should naturally validate your codes in all the authored content before publishing, but we will handle it here nonetheless. Besides, this component can also be used in the CMS, and the <a href="https://github.com/mblarsen/shortcode-tokenizer">shortcode-tokenizer</a> can be used in the backend if you run Node.js.</p>

<p>For this demo, the handling is no more than outputting the error with a token and outputting it to the console.</p>

<h2>Demo time</h2>

<p>Our next step will be to figure out how well this works with theming. For now, let’s see what we have achieved.</p>

<p>Questions and feedback are most welcome. I’m still relatively new to Vue.js myself. If you’ve just started learning Vue.js, make sure to check out <a href="https://www.codementor.io/javascript/tutorial/getting-started-with-vuejs">Getting Started with Vue.js: Why Use it?</a></p>

<p><img src="/assets/img/vue-wordpress-demo.gif" alt="demo-time.gif" />
(Note how syntax errors are shown whenever the the codes are incomplete. <code>ProductCard</code> and <code>ProductListItem</code> are two different components that the <code>ProductList</code> component can use to render a product. <code>Row</code> and <code>Column</code> are simple wrappers around a CSS grid framework.)</p>

<p>References:</p>

<ul>
<li><a href="https://gist.github.com/mblarsen/f628fc3c196b5f58d326242061922446">CodeSlot.vue</a></li>
<li><a href="https://github.com/mblarsen/shortcode-tokenizer">shortcode-tokenizer</a></li>
<li><a href="https://vuejs.org/v2/guide/render-function.html#Functional-Components">Functional Components in Vue</a></li>
</ul>
    ]]></content>
</entry>
    </feed>
